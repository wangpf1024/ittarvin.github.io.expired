---
layout: post
subtitle: 《查找》3小节： 散列表
gh-repo: ittarvin/c_ff
gh-badge: [star, fork, follow]
tags: [数据结构]
comments: false
cover-img: /assets/img/IMG_1414.JPG
thumbnail-img: /assets/img/散列表-数字分析法.png
share-img: /assets/img/IMG_1482.JPG
---

在[顺序查找，二分查找，索引查找](/2022-05-25-search) 和 [二叉排序树](/2022-05-26-search-binary-sort-tree) 中，查找元素时需要进行一系列的键值比较的过程。为了使数据元素的存储位置和键值之间建立某种联系，以减少比较次数。由散列技术实现动态查找表。

# 查找

## 散列表

数据元素的键值和存储位置之间建立的对应关系$H$称为散了函数，用键值通过散了函数获取位置的这种方式构造的存储结构称为散列表（Hash Table），这一映射过程称为散列。如果选定了某个散列函数$H$即相应的散列表$L$，怎对每一个数据元素$X$,函数值$H(X)$就是$X$在散列表$L$中的存储位置，这个存储位置也称为散列地址。

设有散列函数 $H$ 和键值 $k_1$,$k_2$,若$k_1 \neq k_2$ ,但是 $H(k_1) = H(k_2)$ ,则这种现象称为冲突，且 $k_1,k_2$ 称为同义词。因此散列技术需要考虑的两个问题：

1. 如何构造“均匀”的散列函数？
       > 若对键值集合中的任何一个键值，散列函数映射到地址集合中任何一个地址的概率都是相等的，则称次中散列函数是均匀的。
2. 用什么方法有效的解决冲突？

## 常用散列方法

### 数字分析法
数字分析法又称数字选择法，其方法收集所有可能出现的键值，排列在一起，对每一位进行分析，选择分布均匀的若干**位**组成散列地址。所取的位数取决于散列表的表长，见表长 100 ，则取 2 位即可。如图所示 4，6，8，9 位可组织起来作为散列地址。
![散列表-数字分析法.png](/assets/img/散列表-数字分析法.png)

### 除留余数法
除留余数法是一种简单有效且最为常用的构造方法，其方法是选择一个不大于散列表长 n 的整数 p，以键值除以 p 所得的余数作为散列地址，即 p $(p \leq n)$ 通常选择小于散列表长度 n 的素数。

$$
H(key) =key \bmod p
$$

### 平方取中法
平方取中方法是以键值平方的中间几位作为散列地址。这种计算简单，是一种较为常用的构造散列函数的方法，通常在选定 散列函数时候不一定知道键值的分布情况。取其中间的哪几位也不一定合适，而一个数的平方的中间几位与这个数的每一位都有关系，所以散列的比较均匀。

### 基数转换法
将键值看成另外一种进制的数再转换原理进制的数，然后选择其中几位作为散列地址。例如，对于十进制键值 443730，先把它看成是一个13进制的数并转换为10进制。

$$
443730_{13} = 4\times 13^5 + 4\times 13^4 + 3\times 13^3 + 7\times 13^2 + 3\times 13^1 + 0\times 13^0 = 1607229_{10}
$$

然后，根据散列表的长度从中选择几位作为散列地址。


##  解决冲突的方法
假设散列表的地址集为$0 \sim (n-1)$ ，冲突是指由键值得到散列地址上已存有元素，则解决冲突就是为该键值的元素找一个空闲单元的散列地址。通常用来解决冲突方法有以下几种。
> 在解决冲突的过程可能得到一个地址序列$H_i,i=1,2,3,...,k(k\leq H_i \leq n -1)$, 在解决冲突时，若得到的某个散列地址 $H_k$ 仍然发生冲突，则求下一个地址$H_{k+1}$，若仍然有冲突再求 $H_{k+2}$,依此类推直到不发生冲突。这时候得到的散列地址即为该元素在表中的地址。

### 线性探测方法
对于任何键值 key ，设$H(key)=d$ ，设散列表长度为 $m$ ,则线性探测法生成的后续散列地址序列为：

$$
d+1,d+2,...,m-1,0,1,...d-1
$$

例如，下图中长队为13的散列表，其中散列函数为$H(key) = key \bmod 13$ ,在表中填入键值 16，30，54 的元素。现在要插入新的元素 29,计算：$29 \bmod 13 = 3$, 产生地址冲突应用线性探测方法 $d+1=4$，仍然有冲突，则求下一个地址$d+2=5$，这个地址没有元素，将元素填入散列地址序号为5的单元。
![散列表-线性探测法.png](/assets/img/散列表-线性探测法.png)
从图中可用看出30和29本来不是同义词，但是发生了冲突，这种非同义词之间对同一个散列地址争夺的现场称为“堆积”，为了减少堆积的机会，应设法使后继散列地址尽力均匀的分散在整个散列表中。

### 二次探测法
二次探测法的基本思想：生产的后续散列地址不是联系的，而是跳跃式的，以便于为后续数据元素留下空间从而减少堆积。按照二次探测法，键值 key 的散列地址为：

$$
d_0 = H(key)
$$

$$
d_i=(d_0+i) \bmod m
$$

其中，m 为散列表的表长， $i=1^2,-1^2,2^2,-2^2,...,\pm k^2(k\leq m/2)$ 。插入元素 29的过程如图，当发生冲突时，应用二次探测法，得到到下一个$d_1=(3+1^2)=4$仍然冲突，则求下一个 $d_2=(3-1^2)=2$ 仍然冲突，直到散列地址为$d_3=(3+2^2)=7$时，其位置上没有元素，即元素填入散列表序号为7的位置。
![散列表-二次探测法.png](/assets/img/散列表-二次探测法.png){: .mx-auto.d-block :}
二次探测法的缺点时不易探测整个散列表所有空间，也就是说，上述后续散列地址可能难以包括散列表的所有存储位置。

###  链地址法
链地址法是对每一个同义词都建立一个单链表来解决冲突，设选定的散列函数为H，H的值域（散列地址的范围）为$0\sim(n-1)$。设置一个“指针向量” Pointer HP[n],其中的每一个指针HP[i]指向一个单链表，该单链表用来存储所有散列地址为 i 的数据元素。每一个这样的单链表称为一个同义词表。例如，若选定散列函数$H(key)=key \bmod 13$，已存入键值为 26，41，25，05，07，15，12，49，51，31，62 的散列表。如下图所示
![散列表-链地址法.png](/assets/img/散列表-链地址法.png){: .mx-auto.d-block :}

### 多重散列法
此法要求设立多个散列函数$H_i,i=1,...,k$。当给定值 key与散列表中的某个键值是相对于某个散列函数$H_i$的同义词而发生冲突时，继续计算这个给定key在下一个散列函数$H_{i+1}$下的散列地址，直到不再产生冲突为止。优点是不容易产生“堆积”，确定是计算量大。

### 公共溢出区法
按这种方法，散列表由两个一维数组组成。一个称为基本表，它实际上就是上面说的的散列表。，另一个是溢出表，插入首先在基本表上进行，假如发生冲突，则将同义词存入溢出表。这样，基本表不可能发生“堆积”。