---
layout: post
subtitle: 《操作系统》 12小节： 进程调度-调度算法
tags: [操作系统]
comments: false
cover-img: /assets/img/IMG_1753.JPG
thumbnail-img: /assets/img/操作系统概论.jpeg
share-img: /assets/img/IMG_1482.JPG
---

进程调度算法是指从就绪态进程中选择一个或几个进程为其分配CPU，使其进入执行态算法。
不同的调度算法有不同的特点，为了根据特殊应用领域的要求选择合适的调度算法可依[《选择调度方式和算法的若干准则》](../2022-08-06-Operation-System-进程-调度)作为选择依据。

# 操作系统

##  进程调度算法

### 先来先服务调度算法（FCFS）

#### 调度算法

在进程调度中，FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配CPU。

#### 性能分析

FCFS 适合长进程，不利于短进程，短进程等待时间相对于运行时间而言太长。FCFS 使短进程的周转时间过长，系统的平均周转时间也较长。FCFS 有利于CPU繁忙型进程。不利于 I/O 繁忙型进程。

#### 实例分析

有3个进程 p1，p2，p3，分别在 0，1，2 时刻进入系统，需要运行的时间长度分别为 24，3，3，按照 FCFS 调度算法，3个进程的等待时间和周转时间如表：

| 进程名称 | 进入系统时间（已知数值） | 开始运行时间（计算数值） | 服务时间（已知数值） | 等待时间（计算数值） | 周转时间（计算数值） |
|:----:|:------------:|:------------:|:----------:|:----------:|:----------:|
| p    | 0            | 0            | 24         | 0          | 24         |
| p2   | 1            | 24           | 3          | 23         | 26         |
| p3   | 2            | 27           | 3          | 25         | 28         |

执行顺序：p1 -> p2 ->p3

p1: 开始运行时间 0，等待时间 0，周转时间 24。
p2:开始运行时间 24（**p1开始运行时间 + 服务时间**），等待时间 23（开始时间-进入系统时间），周转时间 26（等待时间 + 服务时间）。
p3:开始运行时间 27，等待时间 25，周转时间 28。

系统平均周转时间：= 26

$$
    T = \frac{1}{n}  \bigl [ \sum_{i=1}^n T_i \bigr ] 
$$


平均带权周转时间：$\approx6.33$

$$
W = \frac{1}{n} \bigl[ \sum_{i=1}^n \frac{T_i}{T_s}\bigr]
$$


### 短进程优先调度算法（SPF）

#### 调度算法

短进程优先调度算法就是从就绪队列中选择评估运行时间最短的进程，将处理机分配给他，使他立即执行，并一直执行完成，或发生某事件而被阻塞放弃处理机，而重新调度。

#### 性能分析

与 FCFS 算法相比较，短进程有限算法能有效降低进程的平均等待时间，提供系统吞吐量。

#### 算法缺陷

对长进程不利。如果系统中不断有短进程进入，长进程可能长时间的得不到调度。
不能保证紧迫进程的及时处理。应为该算法不考虑进程的紧迫程度。
进程的长短根据用户的评估而定，故不能做到真正的短进程优先。

#### 实例分析

如果进程进程入系统的顺序为 p3，p2，p1, 3 个进程进入系统的时间分别为：0，1，2 。那么3个进程的等待时间和周转时间如表：


| 进程名称 | 进入系统时间 | 开始运行时间 | 服务时间 | 等待时间 | 周转时间 |
|:----:|:------:|:------:|:----:|:----:|:----:|
| p1   | 2      | 6      | 24   | 4    | 28   |
| p2   | 1      | 3      | 3    | 2    | 5    |
| p3   | 0      | 0      | 3    | 0    | 3    |

系统平均周转时间：= 12

$$
    T = \frac{1}{n}  \bigl [ \sum_{i=1}^n T_i \bigr ] 
$$


平均带权周转时间：$\approx1.28$

$$
W = \frac{1}{n} \bigl[ \sum_{i=1}^n \frac{T_i}{T_s}\bigr]
$$


### 优先权调度算法

#### 调度算法

在使用优先权调度的系统中，每个进程都有一个与之关联的优先权，通常优先权是固定区间的数字。优先权可以通过内部或外部方式来定义：内部定义优先权可以通过使用一些可测量的数据以计算进程的优先权。（例如：内存极限，内存要求，打开文件数量，平均I/O服务时间，平均CPU服务时间）。外部优先权时通过操作系统以外的的准则来衡量的，如进程的重要性，支付使用计算机的费用，数量等。

#### 优先权调度算法类型

##### 非抢占式优先权调度算法

在支持非抢占式的调度系统中，高优先权的进程一旦得到处理机，则该进程将一直运行下去，直到完成或由于某个事件使该进程主动放弃处理机。在运行期间，即使有高优先权的进程到来，系统也不会剥夺当前进程CPU的使用权。

对截止时间要求严格的实时系统中，非抢占式调度难以保证高优先权的进程及时调度。

##### 抢占式优先权调度算法

在支持抢占式的调度系统中，如果新到达的进程的优先权高于当前正在执行进程的优先权，那么系统会抢占CPU，把它分配给高优先权的进程，而正在执行的第优先权的进程暂停。

在抢占式调度系统中，每当系统中出现新的就绪进程，就将其优先权与正在执行的进程的优先权相比较，如果其优先权大于正在执行的进程，可采取立即抢占的策略，立即运行进程切换。也可采用基于时钟[中断](/2022-07-15-Operating-System-系统内核)的策略，在最近的一次时钟终端到来时进行进程切换。

#### 优先权类型

##### 静态优先权

静态优先权在创建时确定，在进程的整个运行期间不变，静态优先权值通常可以根据进程类型，进程需要的资源数量和用户要求来设定。

##### 动态优先权

进程创建时被赋予的优先权，随着进程的推移或随其等待时间的增加而改变。动态优先权可以使系统获得更好的调度性能。

#### 存在问题及解决方案

##### 问题

优先权调度算法的主要问题时无穷阻塞，或者称饥饿问题。

##### 解决方案

低优先权进程无穷等待问题的解决方案之一：老化（Aging）技术，老化技术已逐渐增加在系统中等待时间很长的进程的优先权，是低优先权的进程在等待时间很长的情况下，优先权变高而获得CPU执行。