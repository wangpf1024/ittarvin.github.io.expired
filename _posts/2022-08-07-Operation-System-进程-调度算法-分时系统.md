---
layout: post
subtitle: 《操作系统》 13小节： 时间片轮转调度算法（RR），多级队列调度算法，多级反馈队列调度算法
tags: [操作系统]
comments: false
cover-img: /assets/img/IMG_1753.JPG
thumbnail-img: /assets/img/操作系统概论.jpeg
share-img: /assets/img/IMG_1482.JPG
---
时间片轮转调度算法是现代分时系统中广泛使用的进程调度算法，UNIX，Linux，和 Windows 操作系统都采用基于时间轮转，支持优先权，和抢占式调度的混合进程调度算法。

# 操作系统

##  进程调度算法

### 时间片轮转调度算法（Round-Robin，RR）

#### 调度算法

在采用时间片轮转的调度算法的系统中，进程需要在CPU上运行时间总数（称为时间区间）可能小于一个时间片，可能大于一个时间片。对于进程区间小于一个时间片的情况，进程在CPU上运行结束后，进程本身就会释放CPU。然后有操作系统执行进程调度程序为另一个进程分配CPU。对于进程的时间区间大于一个时间片的情况，进程可能需要执行若干个时间片，每当进程在CPU上连续运行的时间等于一个时间片的长度时，操作系统在时钟终端处理过程中会抢占CPU，进行进程切换，用新的就绪进程代替代替当前进程，被替换的进程重新进入就绪队列中。

> 时间片是一个较小的时间单元，通常为 10 ～ 100 ms 。Linux 2.4  内核中给用户进程分配的时间片大小为 50ms。

#### 时间片大小的确定

在设计时间片轮转调度算法时，时间片的大小确定是一个重要的环节。时间片太长，可以使多数进程在一个时间片内处理完成，能降低进程的周转时间，但可能造成交互用户的响应时间过长。时间片太短，一个进程需要经过多次调度才能执行完毕，进程切换和进程调度的开销增加，系统的平均周转时间也会较长。

在为调度系统确定时间片大小时，通常需要考虑以下几个因素：

- 操作系统对响应时间的要求。
> 系统响应时间 T，进程数目为 N，时间片为 q  有：T = Nq，也就是说响应时间与进程的数目成正比，因此在进程数目一定的情况下，时间片的长短取决于系统要求的响应时间。响应时间越短，时间片越小。

- 就绪队列中的数目。
> 系统允许的最大进程数往往是给定的，系统中的进程数目会影响系统的响应时间，进程越多响应时间越长。系统的响应时间有个上限值，不能应为进程过多而使响应时间很长的情况。当系统设定了最长响应时间后，时间片的大小与系统运行的最大进程数成反比。

- 系统的处理能力。
> 系统的处理能力必须保证系统支持的基本命令能在一个时间片内执行完成，否则将无法保证得到满意的响应的时间，而是会使评价周转时间及带权周转时间都很长


#### 性能评价

时间片轮转调度算法的性能很大程度上依赖时间片的大小。在极端情况，如果时间片很大，那么时间片轮转调度算法和先来先服务算法一样。如果时间片很小，进程需要经过多次上下文切块和进程调度，会大大增加CPU用进程切换和进度调度的开销。


### 多级队列调度
现在操作系统中，进程可以根据不同的特点进程分类，每一类进程属于一个就绪队列。因此，系统中的就绪队列不止一个，而是多个，这种系统通常根据不同进程对响应时间的要求的不同，采用多级队列调度算法。

#### 调度算法
将就绪队列分成多个独立的队列，根据进程的某些属性，如需要占用内存的大小，进程的优先权类型或进程类型，进程会被永久的分配到一个队列中，每个队列有自己的调度算法。不同队列的优先权不同，调度算法也可能不同。

### 多级反馈队列调度

采用多级队列调度，一旦进程进入系统，就被固定的分配到一个就绪队列中，进程在被撤销之前不会在不同的队列中移动。这种算法的优点是降低了进程调度的开销，但不够灵活，对于低优先权的进程就会存在无限阻塞问题。而多级反馈队列可以弥补这些不足。

#### 调度算法

采用多级反馈队列调度的系统中建立多个优先权不同的队列，每个队列赋予大小不同的时间片。
有一种反馈策略可以规定：队列优先权越高，时间片越短，时间片通常成倍增加。新进程被创建后，被插入优先权最高的队列，当优先权最高的队列空时，才调用优先权次之的队列，同一个队列中采用，时间片轮转调度算法。
使用CPU时间过多个的进程被移动到优先权较低的队列中，在较低优先权队列中等待时间过长的进程被移动到较高优先权的队列中。

多级反馈队列算法设计需要考虑的几个因素：

- 就绪队列的数量。
- 根据优先权确定进程应该进如那个就绪队列的算法。
- 用以确定进程何时进入较高优先权队列的算法。
- 用以确认进程何时进入较低优先权队列的算法。
- 用以确认进程需要服务时应该进入那个队列算法。

> 多级反馈队列调度算法一个典型的应用实例是 Linux 2.6.11 内核进程调度算法。
